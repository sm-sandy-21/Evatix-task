import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { focusManagerContext } from '../../util/contextNamespace';
import { KEY_DOWN, KEY_TAB, KEY_UP } from '../../util/keys';
export default class DropdownItemFocusManager extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "registeredItems", []);

    _defineProperty(this, "handleItemRegistered", (itemId, itemNode) => {
      this.registeredItems.push({
        itemId,
        itemNode
      });

      if (this.props.autoFocus && this.registeredItems.length === 1) {
        this.focusedItemId = itemId;
        itemNode.focus();
      }
    });

    _defineProperty(this, "handleItemDeregistered", itemId => {
      this.registeredItems = this.registeredItems.filter(item => item.itemId !== itemId);
    });

    _defineProperty(this, "handleItemFocused", itemId => {
      this.focusedItemId = itemId;
    });

    _defineProperty(this, "handleItemUpdated", (itemId, itemNode) => {
      let matchingIndex = -1;

      for (let i = 0; i < this.registeredItems.length; i++) {
        if (this.registeredItems[i].itemId === itemId) {
          matchingIndex = i;
          break;
        }
      }

      if (matchingIndex === -1) {
        this.handleItemRegistered(itemId, itemNode);
        return;
      }

      this.registeredItems[matchingIndex].itemNode = itemNode;

      if (this.focusedItemIndex() === matchingIndex) {
        itemNode.focus();
      }
    });

    _defineProperty(this, "focusedItemIndex", () => {
      const {
        focusedItemId,
        registeredItems
      } = this;

      for (let i = 0; i < registeredItems.length; i++) {
        if (registeredItems[i].itemId === focusedItemId) {
          return i;
        }
      }

      return -1;
    });

    _defineProperty(this, "handleKeyboard", event => {
      const {
        key,
        shiftKey
      } = event;
      const focusedItemIndex = this.focusedItemIndex();

      if (key === KEY_UP || key === KEY_DOWN) {
        // We prevent default here to avoid page scrolling when up/down
        // pressed while dropdown is focused.
        event.preventDefault();

        if (focusedItemIndex < 0) {
          return;
        }

        const nextItemIndex = key === KEY_UP ? Math.max(0, focusedItemIndex - 1) : Math.min(this.registeredItems.length - 1, focusedItemIndex + 1);
        this.registeredItems[nextItemIndex].itemNode.focus();
      }

      if (key === KEY_TAB) {
        if (!shiftKey && focusedItemIndex === this.registeredItems.length - 1) {
          if (this.props.close) {
            this.props.close({
              event,
              source: 'keydown'
            });
          }
        }

        if (shiftKey && focusedItemIndex === 0) {
          if (this.props.close) {
            this.props.close({
              event,
              source: 'keydown'
            });
          }
        }
      }
    });
  }

  getChildContext() {
    return {
      [focusManagerContext]: {
        itemFocused: this.handleItemFocused,
        registerItem: this.handleItemRegistered,
        deregisterItem: this.handleItemDeregistered,
        updateItem: this.handleItemUpdated
      }
    };
  }

  render() {
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    return /*#__PURE__*/React.createElement("div", {
      onKeyDown: this.handleKeyboard
    }, this.props.children);
  }

}

_defineProperty(DropdownItemFocusManager, "childContextTypes", {
  // eslint-disable-next-line react/forbid-prop-types
  [focusManagerContext]: PropTypes.object
});