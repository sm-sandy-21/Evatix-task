"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _Item = _interopRequireDefault(require("../styled/Item"));

var _ItemParts = require("../styled/ItemParts");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var Item = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(Item, _Component);

  var _super = _createSuper(Item);

  function Item(props) {
    var _this;

    (0, _classCallCheck2.default)(this, Item);
    _this = _super.call(this, props); // The type of element rendered at the root of render() can vary based on the `href`
    // and `linkComponent` props provided. We generate this component here to avoid re-
    // generating the component inside render(). This is for performance reasons, and also
    // allows us to avoid generating a new `ref` for the root element each render().

    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setRef", function (ref) {
      _this.ref = ref;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "href", function () {
      return _this.props.isDisabled ? null : _this.props.href;
    });
    _this.rootComponent = (0, _Item.default)({
      href: _this.href(),
      linkComponent: props.linkComponent
    });
    return _this;
  }

  (0, _createClass2.default)(Item, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.ref && this.props.autoFocus) {
        this.ref.focus();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          _onClick = _this$props.onClick,
          _onKeyDown = _this$props.onKeyDown,
          isCompact = _this$props.isCompact,
          isDisabled = _this$props.isDisabled,
          isDragging = _this$props.isDragging,
          isHidden = _this$props.isHidden,
          isSelected = _this$props.isSelected,
          onMouseEnter = _this$props.onMouseEnter,
          onMouseLeave = _this$props.onMouseLeave,
          role = _this$props.role,
          dnd = _this$props.dnd,
          otherProps = (0, _objectWithoutProperties2.default)(_this$props, ["onClick", "onKeyDown", "isCompact", "isDisabled", "isDragging", "isHidden", "isSelected", "onMouseEnter", "onMouseLeave", "role", "dnd"]);
      var Root = this.rootComponent;
      var dragHandleProps = dnd && dnd.dragHandleProps || null;
      var patchedEventHandlers = {
        onClick: function onClick(event) {
          // rbd will use event.preventDefault() to block clicks that are used
          // as a part of the drag and drop lifecycle.
          if (event.defaultPrevented) {
            return;
          }

          if (!isDisabled && _onClick) {
            _onClick(event);
          }
        },
        onMouseDown: function onMouseDown(event) {
          // rbd 11.x support
          if (dragHandleProps && dragHandleProps.onMouseDown) {
            dragHandleProps.onMouseDown(event);
          } // We want to prevent the item from getting focus when clicked


          event.preventDefault();
        },
        onKeyDown: function onKeyDown(event) {
          // swallowing keyboard events on the element while dragging
          // rbd should already be doing this - but we are being really clear here
          if (isDragging) {
            return;
          } // rbd 11.x support


          if (dragHandleProps && dragHandleProps.onKeyDown) {
            dragHandleProps.onKeyDown(event);
          } // if default is prevented - do not fire other handlers
          // this can happen if the event is used for drag and drop by rbd


          if (event.defaultPrevented) {
            return;
          } // swallowing event if disabled


          if (isDisabled) {
            return;
          }

          if (!_onKeyDown) {
            return;
          }

          _onKeyDown(event);
        }
      };

      var patchedInnerRef = function patchedInnerRef(ref) {
        _this2.setRef(ref); // give rbd the inner ref too


        if (dnd && dnd.innerRef) {
          dnd.innerRef(ref);
        }
      };

      return /*#__PURE__*/_react.default.createElement(Root, (0, _extends2.default)({
        "aria-disabled": isDisabled,
        href: this.href(),
        isCompact: isCompact,
        isDisabled: isDisabled,
        isDragging: isDragging,
        isHidden: isHidden,
        isSelected: isSelected,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        role: role,
        tabIndex: isDisabled || isHidden || this.props.href ? null : 0,
        target: this.props.target,
        title: this.props.title,
        innerRef: patchedInnerRef
      }, dnd && dnd.draggableProps, dragHandleProps, patchedEventHandlers, otherProps), !!this.props.elemBefore && /*#__PURE__*/_react.default.createElement(_ItemParts.Before, {
        isCompact: isCompact
      }, this.props.elemBefore), /*#__PURE__*/_react.default.createElement(_ItemParts.ContentWrapper, null, /*#__PURE__*/_react.default.createElement(_ItemParts.Content, {
        allowMultiline: this.props.shouldAllowMultiline
      }, this.props.children), !!this.props.description && /*#__PURE__*/_react.default.createElement(_ItemParts.Description, {
        isCompact: this.props.isCompact,
        isDisabled: this.props.isDisabled
      }, this.props.description)), !!this.props.elemAfter && /*#__PURE__*/_react.default.createElement(_ItemParts.After, {
        isCompact: isCompact
      }, this.props.elemAfter));
    }
  }]);
  return Item;
}(_react.Component);

exports.default = Item;
(0, _defineProperty2.default)(Item, "defaultProps", {
  autoFocus: false,
  description: '',
  isCompact: false,
  isDisabled: false,
  isHidden: false,
  role: 'button',
  shouldAllowMultiline: false
});