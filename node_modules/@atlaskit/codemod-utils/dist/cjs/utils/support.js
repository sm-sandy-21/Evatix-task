"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNamedSpecifier = getNamedSpecifier;
exports.addCommentBefore = addCommentBefore;
exports.removeImport = removeImport;
exports.tryCreateImport = tryCreateImport;
exports.addToImport = addToImport;
exports.clean = clean;
exports.getSafeImportName = getSafeImportName;
exports.testMethodVariantEach = exports.callExpressionArgMatchesString = exports.debug = exports.isEmpty = exports.shiftDefaultImport = exports.doesIdentifierExist = exports.addCommentToStartOfFile = exports.hasImportDeclaration = exports.hasJSXAttributesByName = exports.getJSXAttributesByName = exports.getDefaultSpecifier = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

function getNamedSpecifier(j, source, specifier, importName) {
  var specifiers = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === specifier;
  }).find(j.ImportSpecifier).filter(function (path) {
    return path.node.imported.name === importName;
  });

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
} // not replacing newlines (which \s does)


var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;

function clean(value) {
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

var addCommentToStartOfFile = function addCommentToStartOfFile(_ref) {
  var j = _ref.j,
      base = _ref.base,
      message = _ref.message;
  addCommentBefore(j, base.find(j.Program), message);
};

exports.addCommentToStartOfFile = addCommentToStartOfFile;

function addCommentBefore(j, target, message) {
  var commentType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'block';
  var messagePrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'TODO: (from codemod) ';
  var msg = clean(messagePrefix + message);
  var content = commentType === 'block' ? " ".concat(msg, " ") : " ".concat(msg);
  target.forEach(function (path) {
    path.value.comments = path.value.comments || [];
    var exists = path.value.comments.find(function (comment) {
      return comment.value === content;
    }); // avoiding duplicates of the same comment

    if (exists) {
      return;
    }

    if (commentType === 'block') {
      path.value.comments.push(j.commentBlock(content));
    } else {
      path.value.comments.push(j.commentLine(content));
    }
  });
}

var getDefaultSpecifier = function getDefaultSpecifier(j, source, specifier) {
  var specifiers = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === specifier;
  }).find(j.ImportDefaultSpecifier);

  if (!specifiers.length) {
    return null;
  }

  return specifiers.nodes()[0].local.name;
}; // @ts-ignore


exports.getDefaultSpecifier = getDefaultSpecifier;

var getJSXAttributesByName = function getJSXAttributesByName(j, element, attributeName) {
  return j(element).find(j.JSXOpeningElement).find(j.JSXAttribute).filter(function (attribute) {
    var matches = j(attribute).find(j.JSXIdentifier).filter(function (identifier) {
      return identifier.value.name === attributeName;
    });
    return Boolean(matches.length);
  });
};

exports.getJSXAttributesByName = getJSXAttributesByName;

var isEmpty = function isEmpty(string) {
  return string && string.value !== '';
};

exports.isEmpty = isEmpty;

var hasImportDeclaration = function hasImportDeclaration(j, source, importPath) {
  var imports = source.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === importPath;
  });
  return Boolean(imports.length);
};

exports.hasImportDeclaration = hasImportDeclaration;

var debug = function debug(component) {
  return function (j, source) {
    var defaultSpecifier = getDefaultSpecifier(j, source, component);

    if (!defaultSpecifier) {
      return;
    }

    source.findJSXElements(defaultSpecifier).forEach(function (element) {
      console.log(element); //eslint-disable-line no-console
    });
  };
};

exports.debug = debug;

var checkForStringWithFormatSpecifier = function checkForStringWithFormatSpecifier(argValue, str) {
  var value = String(argValue);
  var formatSpecifierRegex = /%[a-z]/g;

  if (value && value.match(formatSpecifierRegex)) {
    var formatSpecifierReplacedStr = value.replace(formatSpecifierRegex, '.*');
    var regex = new RegExp(formatSpecifierReplacedStr);
    return regex.test(str);
  } else {
    return false;
  }
};

var checkForTemplateLiteralsWithPlaceholders = function checkForTemplateLiteralsWithPlaceholders(quasis, str) {
  var templateStrs = quasis.map(function (quasi) {
    return quasi.value.raw.trim();
  }).join('.*');
  var regex = new RegExp(templateStrs);
  return regex.test(str);
};

var callExpressionArgMatchesString = function callExpressionArgMatchesString(arg, str) {
  switch (arg.type) {
    case 'StringLiteral':
    case 'Literal':
      {
        if (arg.value === str) {
          return true;
        } else {
          // Eg: 'should contain %s'
          return checkForStringWithFormatSpecifier(arg.value, str);
        }
      }

    case 'TemplateLiteral':
      {
        // fuzzy match template literals, skipping expressions
        var templateStrs = arg.quasis.map(function (quasi) {
          return quasi.value.raw.trim();
        }).join(' ');

        if (str.trim() === templateStrs.trim()) {
          return true;
        } else {
          // Eg: `should contain ${value}`
          return checkForTemplateLiteralsWithPlaceholders(arg.quasis, str);
        }
      }

    case 'BinaryExpression':
      {
        return false;
      }

    default:
      {
        return false;
      }
  }
};

exports.callExpressionArgMatchesString = callExpressionArgMatchesString;

var testMethodVariantEach = function testMethodVariantEach(path, testMethods) {
  var _path$value, _path$value$callee, _path$value$callee$ca, _path$value2, _path$value2$callee, _path$value2$callee$c, _path$value2$callee$c2, _path$value3, _path$value3$callee, _path$value3$callee$c, _path$value3$callee$c2;

  var variants = new Set(['each']);
  return (// @ts-ignore
    ((_path$value = path.value) === null || _path$value === void 0 ? void 0 : (_path$value$callee = _path$value.callee) === null || _path$value$callee === void 0 ? void 0 : (_path$value$callee$ca = _path$value$callee.callee) === null || _path$value$callee$ca === void 0 ? void 0 : _path$value$callee$ca.type) === 'MemberExpression' && // @ts-ignore
    testMethods.has((_path$value2 = path.value) === null || _path$value2 === void 0 ? void 0 : (_path$value2$callee = _path$value2.callee) === null || _path$value2$callee === void 0 ? void 0 : (_path$value2$callee$c = _path$value2$callee.callee) === null || _path$value2$callee$c === void 0 ? void 0 : (_path$value2$callee$c2 = _path$value2$callee$c.object) === null || _path$value2$callee$c2 === void 0 ? void 0 : _path$value2$callee$c2.name) && // @ts-ignore
    variants.has((_path$value3 = path.value) === null || _path$value3 === void 0 ? void 0 : (_path$value3$callee = _path$value3.callee) === null || _path$value3$callee === void 0 ? void 0 : (_path$value3$callee$c = _path$value3$callee.callee) === null || _path$value3$callee$c === void 0 ? void 0 : (_path$value3$callee$c2 = _path$value3$callee$c.property) === null || _path$value3$callee$c2 === void 0 ? void 0 : _path$value3$callee$c2.name)
  );
};

exports.testMethodVariantEach = testMethodVariantEach;

var hasJSXAttributesByName = function hasJSXAttributesByName(j, element, attributeName) {
  return getJSXAttributesByName(j, element, attributeName).length > 0;
};

exports.hasJSXAttributesByName = hasJSXAttributesByName;

var doesIdentifierExist = function doesIdentifierExist(j, base, name) {
  return base.find(j.Identifier).filter(function (identifer) {
    return identifer.value.name === name;
  }).length > 0;
};

exports.doesIdentifierExist = doesIdentifierExist;

function removeImport(j, base, packageName) {
  base.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === packageName;
  }).remove();
}

function tryCreateImport(j, base, relativeToPackage, packageName) {
  var exists = base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === packageName;
  }).length > 0;

  if (exists) {
    return;
  }

  base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === relativeToPackage;
  }).insertBefore(j.importDeclaration([], j.literal(packageName)));
}

function addToImport(j, base, importSpecifier, packageName) {
  base.find(j.ImportDeclaration).filter(function (path) {
    return path.value.source.value === packageName;
  }).replaceWith(function (declaration) {
    return j.importDeclaration([].concat((0, _toConsumableArray2.default)((declaration.value.specifiers || []).filter(function (item) {
      return item.type === 'ImportSpecifier' && item.imported != null;
    })), [importSpecifier]), j.literal(packageName));
  });
}

var shiftDefaultImport = function shiftDefaultImport(j, base, defaultName, oldPackagePath, newPackagePath) {
  tryCreateImport(j, base, oldPackagePath, newPackagePath);
  addToImport(j, base, j.importDefaultSpecifier(j.identifier(defaultName)), newPackagePath); // removing old default specifier

  base.find(j.ImportDeclaration).filter(function (path) {
    return path.node.source.value === oldPackagePath;
  }).remove();
};

exports.shiftDefaultImport = shiftDefaultImport;

function getSafeImportName(_ref2) {
  var j = _ref2.j,
      base = _ref2.base,
      currentDefaultSpecifierName = _ref2.currentDefaultSpecifierName,
      desiredName = _ref2.desiredName,
      fallbackName = _ref2.fallbackName;

  if (currentDefaultSpecifierName === desiredName) {
    return desiredName;
  }

  var isUsed = doesIdentifierExist(j, base, desiredName);
  return isUsed ? fallbackName : desiredName;
}